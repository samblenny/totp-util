<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Clock</title>
<style>
 :root{--F: #88dbb2; --B: #1d1d1d; --H: #32ea39; --L: #3a3a3a; }
 @media (prefers-color-scheme: light){
  :root{--F: #24513e; --B: #efefef; --H: #053a16; --L: #c7c7c7; }}
 html{ background: var(--B); -webkit-text-size-adjust: none; }
 body{ background: var(--B); color: var(--F); min-height: 100vh;
  width: 100%; font-family: sans-serif; font-size: 18px; }
 html,body,h1,h2,main{ margin: 0; padding: 0; box-sizing: border-box; }
 code,p,td{ line-height: 1.23em; }
 h1{ margin: 20px 0 15px -3px; font-size: 38px; color: var(--H); }
 h2{ margin: 33px 0 15px -3px; font-size: 22px; color: var(--H); }
 table{ margin: 11px 0; border-collapse: collapse; }
 table,td{ border: 1px solid var(--L); }
 td{ padding: 10px; }
 td:last-child{ min-width: 22ch; }
 p,canvas{ margin: 11px 0; }
 main{ margin: 0 auto; padding: 2px 25px 15px 25px; max-width: 600px; }
 #barcode{ margin: 11px 0; border: 1px solid var(--L);
  image-rendering: pixelated; }
</style>
</head>
<body>
<main>
<h1>Clock</h1>
<table>
<tr><td>UTC</td>  <td><code id="utc"></code></td> </tr>
</table>
<h2>MMDDhhmmCCYYss</h2>
<table>
<tr><td>UTC</td>
<td><code id="shell">Check developer tools console for errors</code></td>
</tr>
</table>
<canvas id="qrCanvas" width="145" height="145"></canvas>
</main>

<script>
"use strict";
let utcP     = document.querySelector("#utc");
let shellP   = document.querySelector("#shell");
let qrCanvas = document.querySelector("#qrCanvas");
let qrCtx    = qrCanvas.getContext("2d");

class QRCode {
    static oneshotArmed = true; // TODO: remove this

    static numericRE = /^[0-9]+$/; // Regular expression for numeric data
    static pxPerModule = 5;   // Size of QR code module in pixels
    static quiet = 4;         // Width of quiet zone in modules
    static version = 1;       // Fits 14 digits (MMDDHHMMCCYYss)
    static ecc = "H";         // Error correction level
    static maxDigits = 17;    // Version 1-H fits up to 17 digits
    static dataBits = 72;     // Version 1-H number of data bits
    static dataCodewords = 9; // Version 1-H number of codewords
    static ecCodewords = 17;  // Ver 1-H number of error correction codewords
    static ecPVal = 1;        // Ver 1-H value of error correction p
    static ecBlocks = 1;      // Ver 1-H number of error correction blocks

    // Convert integer to bit array (MSB first) and append to bitstream.
    // For example n=5, numBits=4 would append [0,1,0,1] to stream.
    static appendAsBits(stream, n, numBits) {
        for(let shift=numBits-1; shift>=0; shift--) {
            stream.push((n>>shift) & 1);
        }
    }

    // Encode data as a numeric mode QR code bitstream
    constructor(data) {
        // TODO: remove the oneshot bypass mechanism. It exists to prevent huge
        // console.log debug spew as I work on implementing the QR code spec.
        if(!QRCode.oneshotArmed) {
            return;
        } else {
            QRCode.oneshotArmed = false;
            console.log("oneshot logger enable is now off");
        }
        if(!data.match(QRCode.numericRE)) {
            throw new Error("Unsupported data format (non-numeric characters):"
                + ` ${data}`);
        }
        if(data.length > QRCode.maxDigits) {
            let msg = `Version ${QRCode.version} ECC ${QRCode.ecc} can fit up `
                + `to ${QRCode.maxDigits} digits, ${data.length} is too long`;
            throw new Error(msg);
        }
        // Convert string of ASCII numeric digits, /[0-9]+/ into an array of
        // equivalent decimal integers. Note that "0" is 0x30 and "9" is 0x39.
        let characters = Array.from(data);
        const digits = characters.map((c) => c.charCodeAt(0) & 0xf);
        console.log("digits:", digits);
        // Pack data bitstream. Segments begin with most significant bit
        // 1. Numeric mode indicator (0b0001, 4 bits, MSB first)
        let stream = new Array();
        QRCode.appendAsBits(stream, 0b0001, 4);
        // 2. Version 1 numeric mode character count indicator (10 bits).
        QRCode.appendAsBits(stream, digits.length, 10);
        // 3. Pack data digits:
        //    First pack each full of 3 digits (range 000..999) as 10 bits.
        //    If 2 digits are left over (range 00..99), pack them as 7 bits.
        //    If only 1 digit is left over (range 0..9), pack it as 4 bits.
        const trigrams = Math.floor(digits.length / 3);
        for(let i=0; i<trigrams*3; i+=3) {
            let n = (digits[i]*100) + (digits[i+1]*10) + digits[i+2];
            QRCode.appendAsBits(stream, n, 10);
        }
        const digitsRemainder = digits.length % 3;
        if(digitsRemainder == 2) {             // Last 2 digits as 7 bits
            const i = digits.length - 2;
            const n = (digits[i]*10) + digits[i+1];
            QRCode.appendAsBits(stream, n, 7);
        } else if(digitsRemainder == 1) {      // Final digit as 4 bits
            const i = digits.length - 1;
            QRCode.appendAsBits(stream, digits[i], 4);
        }
        // 4. Pack Terminator sequence (0b0000, 4 bits, or abbreviate to fit)
        const untermLen = stream.length;
        const availableBits = QRCode.maxDataBits - untermLen;
        if(availableBits > 0) {
            if (availableBits < 4) {
                QRCode.appendAsBits(stream, 0b0000, availableBits);
            } else {
                QRCode.appendAsBits(stream, 0b0000, 4);
            }
        }
        // 5. Pad data bit stream with minimum number of 0's that will give a
        //    stream length that is a multiple of 8 bits
        const unpaddedBitsLen = stream.length;
        console.log("unpaddedBitsLen:", unpaddedBitsLen);
        const extraBits = unpaddedBitsLen % 8;
        if(extraBits > 0) {
            QRCode.appendAsBits(stream, 0, 8-extraBits);
        }
        console.log("stream:", stream);
        console.log("stream.length:", stream.length);
        // 6. Convert bit stream to codewords
        const paddedBitsLen = stream.length;
        const unpaddedCWLen = Math.floor(paddedBitsLen / 8);
        console.log("paddedBitsLen:", paddedBitsLen);
        console.log("unpaddedCWLen:", unpaddedCWLen);
        let codewords = new Array();
        for(let i=0; i<unpaddedCWLen; i++) {
            let bits = stream.slice(i*8, (i+1)*8);
            const initialVal = 0;
            let n = bits.reduce((acc, curr) => (acc*2) + curr, initialVal);
            codewords.push(n);
        }
        console.log("codewords:", codewords);
        console.log("codewords.length:", codewords.length);
        // 7. Add alternating Pad codewords to reach the full data codeword
        //    capacity of this symbol version
        const padCWNeeded = QRCode.dataCodewords - codewords.length;
        const padCWDiv2 = padCWNeeded >> 1;
        const alternatingPad1 = 0b11101100;
        const alternatingPad2 = 0b00010001;
        for(let i=0; i<(padCWNeeded>>1); i++) { // Divisible by 2 padding
            codewords.push(alternatingPad1);
            codewords.push(alternatingPad2);
        }
        if((padCWNeeded & 1) == 1) {            // Remainder %2 padding
            codewords.push(alternatingPad1);
        }
        console.log("padded codewords:", codewords);
        console.log("padded codewords.length:", codewords.length);

        // TODO: finish this (EC codewords, etc)
    }

    // Draw QR code 1:1:3:1:1 finder pattern with top-left coordinate (x,y).
    // Caller must set strokeStyle="black" and fillStyle="black".
    drawFinderPattern(ctx, x, y) {
        const p = QRCode.pxPerModule;
        const half = p*0.5;
        let side = (7*p)-p;
        ctx.strokeRect((x*p)+half, (y*p)+half, side, side);
        side = 3*p;
        ctx.fillRect((x+2)*p, (y+2)*p, side, side);
    }

    // Draw clock rows between bottom edge of the two top finder patterns and
    // the right edges of the two leftmost finder patterns.
    drawClockRows(ctx) {
        const p = QRCode.pxPerModule;
        const count = 1 + (2 * QRCode.version);
        // Calculate (x,y) for horizontal row, swap coords for vertical row
        let x0 = QRCode.quiet + 8;
        let y = (QRCode.quiet + 6) * p;
        for(let n=0; n<count; n++) {
            let x = (x0 + (n*2)) * p;
            ctx.fillRect(x, y, p, p); // Horizontal row
            ctx.fillRect(y, x, p, p); // Vertical row (swapped x,y)
        }
    }

    // Draw QR code to ctx, the 2d context of a canvas element
    draw(ctx) {
        // Clear canvas
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, ctx.width, ctx.height);
        // Finder patterns
        ctx.fillStyle = "black";
        ctx.strokeStyle = "black";
        ctx.lineWidth = QRCode.pxPerModule;
        const q = QRCode.quiet;
        const offset = 10 + (QRCode.version * 4);
        this.drawFinderPattern(ctx, q, q);
        this.drawFinderPattern(ctx, q + offset, q);
        this.drawFinderPattern(ctx, q, q + offset);
        // Clock rows
        this.drawClockRows(ctx);
        // TODO:
        // 1. Encode data:
        //    - Make bit stream: Mode Indicator, Data Sequence, Terminator
        //    - Split bit stream into 8-bit codewords
        //    - Add Pad characters to fill codewords for version
        // 2. Encode error correction:
        //    - Divide codewords into blocks
        //    - Generate EC codewords for blocks
        //    - Append EC codewords to data codewords
        // 3. Form message
        //    - Interleave data and EC codewords
        //    - Add remainder bits if needed
        //    - Place codeword modules into matrix
        // 4. Masking
        //    - Measure symbol quality for each mask pattern
        //    - Pick best mask pattern
        // 5. Format version info
        //    - Version, Mask, EC Level
    }
}


// Configure the canvas to hold the right QR code version
function sizeCanvas(version, pxPerModule, quietModules) {
    const modules = 17 + (version * 4);
    const quiet = quietModules * 2;
    const width = (modules + quiet) * pxPerModule;
    const height = (modules + quiet) * pxPerModule;
    qrCanvas.width = width;
    qrCanvas.height = height;
    qrCtx.width = width;
    qrCtx.height = height;
}

// Pad with 0 to get a two digit string
function pad(n) {
    return (n<10) ? `0${n}` : `${n}`;
}

// Update clock and schedule another update aligned to the next second
// CAUTION! The Javascript Date API is weird (see comments below)
function updateClock() {
    // Unix time
    let unix_ms = 1000 * (Math.floor(Date.now() / 1000));
    let d = new Date();
    d.setTime(unix_ms);
    // UTC time
    let mon  = pad(d.getUTCMonth() + 1) // month is zero-indexed
    let day  = pad(d.getUTCDate())      // getUTCDate() gives day of the month
    let hour = pad(d.getUTCHours())
    let min  = pad(d.getUTCMinutes())
    let year = d.getUTCFullYear()
    let sec  = pad(d.getUTCSeconds())
    let utc = `${year}-${mon}-${day} ${hour}:${min}:${sec}`;
    // Date string is intended for setting time on Linux, like:
    //   date --utc MMDDhhmmCCYY.ss
    //
    // To encode the QR code more efficiently, only the numerals are included.
    // This is meant for use with a wrapper script that will validate the
    // numeric timestamp and format a `date ...` shell command string to set
    // the time.
    let shellTime = `${mon}${day}${hour}${min}${year}${sec}`
    let qr = new QRCode(shellTime);
    qr.draw(qrCtx);
    // Update the DOM elements
    utcP.innerHTML = utc;
    shellP.innerHTML = shellTime;
    // Schedule another update aligned on transition to the next second
    let ms = 1000 - (Date.now() % 1000);
    window.setTimeout(updateClock, ms);
}

// Prepare the canvas
sizeCanvas(QRCode.version, QRCode.pxPerModule, QRCode.quiet);
// Start the reccuring clock updater
updateClock();
</script>
</body>
</html>
